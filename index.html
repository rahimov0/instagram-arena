<!doctype html>
<html lang="tr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Takipçi Arenası – Public Avatar + Mapping (Uyumlu)</title>
<style>
  :root{ --bg:#0b1020; --card:#121831; --acc:#5aa8ff; --mut:#a8b6d3 }
  *{box-sizing:border-box} body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans;background:var(--bg);color:#eaf1ff}
  header{position:sticky;top:0;padding:14px 18px;border-bottom:1px solid #1b2347;background:linear-gradient(180deg,rgba(11,16,32,.98),rgba(11,16,32,.92));backdrop-filter:blur(6px);z-index:5}
  h1{margin:0;font-size:18px}
  .wrap{display:grid;grid-template-columns:380px 1fr;gap:16px;padding:16px}
  .card{background:var(--card);border:1px solid #1b2347;border-radius:14px;padding:14px;box-shadow:0 6px 18px rgba(0,0,0,.25)}
  label{display:block;color:var(--mut);font-size:13px;margin-bottom:6px}
  input[type="file"],input[type="number"],textarea{width:100%;padding:10px 12px;border-radius:10px;border:1px solid #273159;background:#0f1630;color:#eaf1ff}
  textarea{min-height:90px;resize:vertical}
  button{background:var(--acc);color:#0b1020;border:none;border-radius:10px;padding:10px 14px;font-weight:700;cursor:pointer}
  button.ghost{background:#0f1630;color:#cfe2ff;border:1px solid #273159}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .mut{color:#a8b6d3;font-size:12px}
  .log{background:#0f1630;border:1px solid #273159;border-radius:10px;padding:10px;font:12px/1.5 ui-monospace,Menlo,Consolas,monospace;color:#d9e7ff;max-height:160px;overflow:auto;white-space:pre-wrap}
  .stats{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-top:10px}
  .stat{background:#0f1630;border:1px solid #273159;border-radius:10px;padding:8px 10px;font-size:12px;color:#cfe2ff}
  .stat b{font-size:18px;display:block;color:#fff}
  #stageBox{position:relative;width:100%;aspect-ratio:16/9;min-height:520px;border-radius:14px;overflow:hidden}
  #stage{width:100%;height:100%;display:block;background:radial-gradient(1100px 700px at 70% 20%, #0f1b3d, #0a0f22)}
  @media (max-width:820px){ .wrap{grid-template-columns:1fr} #stageBox{aspect-ratio:auto;height:min(100dvw,100dvh-240px);min-height:360px} }
</style>
</head>
<body>
<header><h1>Takipçi Arenası – Public Proxy + Avatar Mapping</h1></header>

<div class="wrap">
  <div class="card">
    <h3>Katılımcı listesi</h3>
    <label>Instagram JSON (followers.json / connections.json) veya CSV; ya da elle yapıştır (@kullanici / profil URL / sadece ad)</label>
    <input id="fileUsers" type="file" accept=".json,.csv">
    <textarea id="paste" placeholder="@ahmet
https://www.instagram.com/ayse/
mehmet" style="margin-top:8px"></textarea>

    <h3 style="margin-top:14px">Avatar mapping (opsiyonel – kapalı hesaplar için izinli görsel)</h3>
    <label>CSV: <code>username,image</code> | JSON: <code>[{"username":"ayse","img":"https://.../ayse.png"}]</code></label>
    <input id="fileMap" type="file" accept=".json,.csv">

    <div class="row" style="margin-top:10px">
      <button id="importBtn">İçe aktar</button>
      <button id="demoBtn" class="ghost">Demo 5K</button>
      <button id="clearBtn" class="ghost">Temizle</button>
    </div>
    <p class="mut" id="info"></p>

    <h3 style="margin-top:12px">Ayarlar</h3>
    <label>Görüntülü avatar eşiği (kalan kişi bu sayının altına düşünce PP'ler görünür)</label>
    <input id="maxImagePlayers" type="number" value="1200" min="0" step="100">
    <label>FPS azaltma</label>
    <input id="renderSkip" type="number" value="1" min="0" max="10">

    <h3 style="margin:12px 0 6px;">Auto-Scale (kalabalık azaldıkça büyüt)</h3>
    <div class="row">
      <label style="margin:0">Min yarıçap</label><input id="minR" type="number" value="5" min="2" max="30" style="width:90px">
      <label style="margin:0">Max yarıçap</label><input id="maxR" type="number" value="16" min="4" max="60" style="width:90px">
      <label style="margin:0">Eğri</label><input id="curve" type="number" value="0.6" step="0.1" min="0.1" max="3" style="width:90px">
    </div>
    <p class="mut">Daire boyutu: <code>lerp(minR, maxR, (1 - alive/başlangıç)^eğri)</code></p>

    <div class="row" style="margin-top:8px">
      <button id="startBtn">Başlat</button>
      <button id="stopBtn" class="ghost">Durdur</button>
      <button id="resetBtn" class="ghost">Sıfırla</button>
    </div>

    <div class="stats">
      <div class="stat"><b id="statTotal">0</b><span>Başlangıç</span></div>
      <div class="stat"><b id="statAlive">0</b><span>Hayatta</span></div>
      <div class="stat"><b id="statAv">0</b><span>Yüklenen PP</span></div>
    </div>
    <div class="log" id="log" style="margin-top:10px"></div>
    <p class="mut" style="margin-top:6px">Not: /api/avatar yalnızca <b>açık profiller</b> için çalışır. Kapalı hesaplarda mapping dosyasındaki görsel kullanılır; yoksa daire gösterilir.</p>
  </div>

  <div class="card"><div id="stageBox"><canvas id="stage"></canvas></div></div>
</div>

<script>
const $=id=>document.getElementById(id);
const logBox=$('log'); function log(m){ logBox.textContent += m+"\\n"; logBox.scrollTop = logBox.scrollHeight; }

const canvas=$('stage'); const ctx=canvas.getContext('2d',{alpha:false});
let names=[], posX, posY, velX, velY, hp, alive;
let running=false, ringR=0, last=0, startCount=0;
const SPEED = 100;        // px/s
const SHRINK = 0.8;       // ring shrink hızı
const OUT_DAMAGE = 0.004;  // ring dışı hasar
const avatarCache = new Map();   // username -> Image|null
const avatarMap = new Map();     // username -> imgURL (mapping dosyasından)

function resize(){ const box=document.getElementById('stageBox'); const r=box.getBoundingClientRect(); const dpr=window.devicePixelRatio||1; canvas.width=r.width*dpr; canvas.height=r.height*dpr; ctx.setTransform(dpr,0,0,dpr,0,0); ringR=Math.min(r.width,r.height)*0.48; }
addEventListener('resize',resize); addEventListener('orientationchange',resize); resize();

// ---------- IMPORT ----------
function normalizeUsername(x){
  if(!x) return "";
  x = String(x).trim().replace(/^@/,"");
  try{
    if(/^https?:\/\//i.test(x)){
      const url = new URL(x);
      if(url.hostname.includes("instagram.com")){
        const parts = url.pathname.split("/").filter(Boolean);
        if(parts.length){
          const p0 = parts[0].toLowerCase();
          if(["reel","p","stories","explore"].includes(p0)) return "";
          return parts[0];
        }
      }
      return "";
    }
  }catch(e){}
  return x;
}
function parseTextList(t){
  const raw = t.split(/\\r?\\n+/).map(s=>s.trim()).filter(Boolean);
  const out=[]; for(const line of raw){ const u=normalizeUsername(line); if(u) out.push(u); }
  return Array.from(new Set(out));
}
async function parseUsersFile(f){
  const t=await f.text(); const n=f.name.toLowerCase();
  if(n.endsWith('.csv')) return parseTextList(t);
  try{ const j=JSON.parse(t); return extractUsernamesFromInstagramJSON(j);}catch(e){ alert('Kullanıcı JSON hatalı: '+e); return []; }
}
function extractUsernamesFromInstagramJSON(data){
  let out=[]; const push=u=>{const n=normalizeUsername(u); if(n) out.push(n);};
  (function walk(o){
    if(!o) return;
    if(Array.isArray(o)){ for(const it of o) walk(it); return; }
    if(typeof o==='object'){
      if('username' in o && typeof o.username==='string') push(o.username);
      if('string_list_data' in o && Array.isArray(o.string_list_data)){
        for(const it of o.string_list_data){ if(it && typeof it.value==='string') push(it.value); }
      }
      for(const k in o) walk(o[k]);
    }
  })(data);
  return Array.from(new Set(out));
}
async function parseMapFile(f){
  const t=await f.text(); const n=f.name.toLowerCase();
  avatarMap.clear();
  if(n.endsWith('.csv')){
    // CSV: username,image
    t.split(/\\r?\\n+/).forEach(line=>{
      const [u,img]=line.split(',').map(s=>s&&s.trim());
      const nu=normalizeUsername(u); if(nu && img) avatarMap.set(nu, img);
    });
  } else {
    try{
      const arr = JSON.parse(t);
      for(const it of arr){ if(it && it.username && it.img){ const nu=normalizeUsername(it.username); if(nu) avatarMap.set(nu, it.img); } }
    }catch(e){ alert('Mapping JSON hatalı: '+e); }
  }
  log('Mapping yüklendi: '+avatarMap.size+' kayıt');
}

// ---------- UI ----------
$('clearBtn').onclick=()=>{ names=[]; avatarMap.clear(); avatarCache.clear(); $('info').textContent=''; logBox.textContent=''; $('statTotal').textContent='0'; $('statAlive').textContent='0'; $('statAv').textContent='0'; };
$('demoBtn').onclick=()=>{ const N=3000; names=Array.from({length:N},(_,i)=>'demo_'+(i+1)); $('info').textContent='Demo: '+N; log('Demo listesi hazır ('+N+')'); };
$('importBtn').onclick=async()=>{
  logBox.textContent='';
  let list=[];
  const fu=$('fileUsers').files[0]; if(fu){ list = await parseUsersFile(fu); }
  const pasted = parseTextList($('paste').value); if(pasted.length) list = list.concat(pasted);
  list = Array.from(new Set(list));
  if(!list.length){ alert('Hiç kullanıcı bulunamadı. JSON/CSV veya yapıştır.'); log('İçe aktarma: 0'); return; }
  const fm=$('fileMap').files[0]; if(fm){ await parseMapFile(fm); }
  names=list; $('info').textContent='Toplam kullanıcı: '+names.length; log('İçe aktarma tamam: '+names.length);
};

$('startBtn').onclick=()=>{ if(!names.length){ alert('Önce içe aktar'); return; } init(); running=true; last=performance.now(); requestAnimationFrame(loop); };
$('stopBtn').onclick=()=>running=false;
$('resetBtn').onclick=()=>{ running=false; avatarCache.clear(); $('statAv').textContent='0'; };

// ---------- GAME ----------
function init(){
  const N=names.length; startCount=N;
  const r=canvas.getBoundingClientRect(), cx=r.width/2, cy=r.height/2;
  posX=new Float32Array(N); posY=new Float32Array(N); velX=new Float32Array(N); velY=new Float32Array(N); hp=new Float32Array(N); alive=new Uint8Array(N);
  for(let i=0;i<N;i++){
    const a=Math.random()*6.283, rr=Math.random()*ringR*0.9; posX[i]=cx+Math.cos(a)*rr; posY[i]=cy+Math.sin(a)*rr;
    const th=Math.random()*6.283, v=SPEED/60; velX[i]=Math.cos(th)*v; velY[i]=Math.sin(th)*v;
    hp[i]=1; alive[i]=1;
  }
  $('statTotal').textContent=String(N); $('statAlive').textContent=String(N);
  progressiveLoad(N);
}
function progressiveLoad(N){
  const conc=12; let i=0,inflight=0;
  function next(){ while(inflight<conc && i<N){ const u=names[i++]; inflight++; fetchAvatar(u).finally(()=>{ inflight--; next(); }); } }
  next();
}
function fetchAvatar(u){
  if(!u) return Promise.resolve();
  if(avatarCache.has(u)) return Promise.resolve();
  // 1) Mapping varsa onu kullan
  const m = avatarMap.get(u);
  if(m){
    const img=new Image(); img.crossOrigin='anonymous';
    img.onload=()=>{ avatarCache.set(u,img); bumpAv(); }; img.onerror=()=>{ avatarCache.set(u,null); };
    img.src = m; return Promise.resolve();
  }
  // 2) Açıksa proxy ile dene
  const url = `/api/avatar?u=${encodeURIComponent(u)}`;
  const img=new Image(); img.crossOrigin='anonymous';
  img.onload=()=>{ avatarCache.set(u,img); bumpAv(); }; img.onerror=()=>{ avatarCache.set(u,null); };
  img.src = url; return Promise.resolve();
}
function bumpAv(){ const n=parseInt($('statAv').textContent||"0",10)+1; $('statAv').textContent=String(n); }

function loop(ts){
  if(!running) return;
  const dt=Math.min(50, ts-last); last=ts;
  update(dt/16.6667);
  const skip=Math.max(0, parseInt($('renderSkip').value)||1);
  if((Math.floor(ts/16) % (skip+1))===0) draw();
  requestAnimationFrame(loop);
}
function update(f){
  const r=canvas.getBoundingClientRect(); const cx=r.width/2, cy=r.height/2;
  ringR = Math.max(60, ringR - SHRINK*f);
  for(let i=0;i<posX.length;i++){
    if(!alive[i]) continue;
    posX[i]+=velX[i]*f; posY[i]+=velY[i]*f;
    const dx=posX[i]-cx, dy=posY[i]-cy; const dist=Math.hypot(dx,dy);
    if(dist>ringR){ velX[i]-=(dx/dist)*0.02*f; velY[i]-=(dy/dist)*0.02*f; hp[i]-=OUT_DAMAGE*f; if(hp[i]<=0){ alive[i]=0; } }
    if(posX[i]<5||posX[i]>r.width-5) velX[i]*=-1; if(posY[i]<5||posY[i]>r.height-5) velY[i]*=-1;
    velX[i] += (Math.random()-0.5)*0.002*f; velY[i] += (Math.random()-0.5)*0.002*f;
  }
  let aliveCount=0; for(let i=0;i<alive.length;i++) aliveCount+=alive[i];
  $('statAlive').textContent=String(aliveCount);
}
function draw(){
  const r=canvas.getBoundingClientRect(); ctx.clearRect(0,0,r.width,r.height);
  // ring
  ctx.strokeStyle='#5aa8ff'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(r.width/2, r.height/2, ringR, 0, Math.PI*2); ctx.stroke();

  // auto-scale radius
  const aliveCount = parseInt($('statAlive').textContent)||startCount;
  const minR = Math.max(2, parseFloat($('minR').value)||5);
  const maxR = Math.max(minR+1, parseFloat($('maxR').value)||16);
  const curve = Math.max(0.1, parseFloat($('curve').value)||0.6);
  const tRaw = 1 - (aliveCount / Math.max(1,startCount));
  const t = Math.pow(Math.max(0, Math.min(1, tRaw)), curve);
  const radius = minR + (maxR - minR) * t;

  const N = posX.length;
  const maxImg=parseInt($('maxImagePlayers').value)||1200;
  const useImg = aliveCount <= maxImg;

  if(!useImg){
    ctx.fillStyle='#a9c7ff';
    for(let i=0;i<N;i++){
      if(!alive[i]) continue;
      ctx.beginPath(); ctx.arc(posX[i], posY[i], radius, 0, 6.283); ctx.fill();
    }
  } else {
    for(let i=0;i<N;i++){
      if(!alive[i]) continue;
      const u=names[i]; const im=avatarCache.get(u);
      if(im){
        ctx.save(); ctx.beginPath(); ctx.arc(posX[i], posY[i], radius, 0, 6.283); ctx.clip();
        ctx.drawImage(im, posX[i]-radius, posY[i]-radius, radius*2, radius*2);
        ctx.restore();
      } else {
        ctx.fillStyle='#a9c7ff'; ctx.beginPath(); ctx.arc(posX[i], posY[i], radius, 0, 6.283); ctx.fill();
      }
    }
  }
}
</script>
</body>
</html>
